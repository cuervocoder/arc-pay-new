{
  "version": 3,
  "sources": ["../bundle-o2i6jh/checked-fetch.js", "../../../payment_service.js", "../../../openai_service.js", "../../../subscription_service.js", "../../../index.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-o2i6jh/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-o2i6jh/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/subhransu/Desktop/arc-pay-new/backend/.wrangler/tmp/dev-rhy24u",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\n * Payment Service for Cloudflare Workers\n * Handles USDC payments via Circle SDK\n */\n\nexport class PaymentService {\n  constructor(env) {\n    this.env = env;\n    this.circleApiKey = env.CIRCLE_API_KEY;\n    this.entitySecret = env.ENTITY_SECRET;\n    this.circleApiUrl = 'https://api.circle.com/v1';\n  }\n\n  /**\n   * Process micropayment for content\n   */\n  async processMicropayment(userId, decision, env) {\n    if (!decision.shouldPay) {\n      throw new Error('Payment decision is negative');\n    }\n\n    // Get or create user wallet\n    const wallet = await this.getUserWallet(userId, env);\n\n    // Execute payment\n    const transaction = await this.sendPayment(\n      wallet.walletId,\n      decision.creatorAddress,\n      decision.amount,\n      decision.contentId\n    );\n\n    return transaction;\n  }\n\n  /**\n   * Get user wallet from KV or create new one\n   */\n  async getUserWallet(userId, env) {\n    const walletKey = `wallet-${userId}`;\n    let walletData = await env.USER_PREFS.get(walletKey);\n\n    if (walletData) {\n      return JSON.parse(walletData);\n    }\n\n    // Create new wallet\n    const wallet = await this.createWallet(userId);\n    \n    // Store in KV\n    await env.USER_PREFS.put(walletKey, JSON.stringify(wallet));\n\n    return wallet;\n  }\n\n  /**\n   * Create wallet using Circle API\n   */\n  async createWallet(userId) {\n    try {\n      const response = await fetch(`${this.circleApiUrl}/wallets`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.circleApiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          idempotencyKey: `wallet-${userId}-${Date.now()}`,\n          accountType: 'SCA',\n          blockchains: ['ARB-SEPOLIA'],\n          count: 1,\n          walletSetId: userId\n        })\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new Error(`Circle API error: ${error}`);\n      }\n\n      const data = await response.json();\n      const wallet = data.data.wallets[0];\n\n      return {\n        address: wallet.address,\n        walletId: wallet.id,\n        userId,\n        createdAt: new Date().toISOString()\n      };\n\n    } catch (error) {\n      console.error('Error creating wallet:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send USDC payment\n   */\n  async sendPayment(fromWalletId, toAddress, amount, contentId) {\n    try {\n      // Check balance first\n      const balance = await this.getWalletBalance(fromWalletId);\n      \n      if (balance < amount) {\n        throw new Error(`Insufficient balance: ${balance} USDC available, ${amount} USDC required`);\n      }\n\n      // Create transaction\n      const response = await fetch(`${this.circleApiUrl}/w3s/developer/transactions/transfer`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.circleApiKey}`,\n          'Content-Type': 'application/json',\n          'X-User-Token': this.entitySecret\n        },\n        body: JSON.stringify({\n          idempotencyKey: `payment-${contentId}-${Date.now()}`,\n          walletId: fromWalletId,\n          blockchain: 'ARB-SEPOLIA',\n          destinationAddress: toAddress,\n          tokenAddress: this.env.USDC_ADDRESS || '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',\n          amounts: [amount.toString()],\n          fee: {\n            type: 'level',\n            config: {\n              feeLevel: 'MEDIUM'\n            }\n          }\n        })\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new Error(`Circle transaction error: ${error}`);\n      }\n\n      const data = await response.json();\n      const tx = data.data.transaction;\n\n      return {\n        txHash: tx.txHash || tx.id,\n        from: fromWalletId,\n        to: toAddress,\n        amount,\n        contentId,\n        timestamp: new Date().toISOString(),\n        status: tx.state || 'PENDING'\n      };\n\n    } catch (error) {\n      console.error('Error sending payment:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get wallet balance\n   */\n  async getWalletBalance(walletId) {\n    try {\n      const response = await fetch(`${this.circleApiUrl}/wallets/${walletId}`, {\n        headers: {\n          'Authorization': `Bearer ${this.circleApiKey}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get balance: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const usdcBalance = data.data.wallet.balances?.find(\n        b => b.token.symbol === 'USDC'\n      );\n\n      return parseFloat(usdcBalance?.amount || '0');\n\n    } catch (error) {\n      console.error('Error getting balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get transaction status\n   */\n  async getTransactionStatus(txHash) {\n    try {\n      const response = await fetch(`${this.circleApiUrl}/w3s/transactions/${txHash}`, {\n        headers: {\n          'Authorization': `Bearer ${this.circleApiKey}`\n        }\n      });\n\n      if (!response.ok) {\n        return 'UNKNOWN';\n      }\n\n      const data = await response.json();\n      return data.data.transaction.state;\n\n    } catch (error) {\n      console.error('Error getting transaction status:', error);\n      return 'UNKNOWN';\n    }\n  }\n}\n", "/**\n * OpenAI Service for Cloudflare Workers\n * Uses Cloudflare AI for inference when available, falls back to OpenAI API\n */\n\nexport class OpenAIService {\n  constructor(env) {\n    this.env = env;\n    this.openaiKey = env.OPENAI_API_KEY;\n  }\n\n  /**\n   * Analyze content using AI\n   * @param {Object} content \n   * @param {Object} userPreferences \n   */\n  async analyzeContent(content, userPreferences) {\n    // Try Cloudflare AI first (if available in your plan)\n    if (this.env.AI) {\n      return await this.analyzeWithCloudflareAI(content, userPreferences);\n    }\n\n    // Fallback to OpenAI API\n    if (this.openaiKey) {\n      return await this.analyzeWithOpenAI(content, userPreferences);\n    }\n\n    // Final fallback: keyword matching\n    return this.fallbackAnalysis(content, userPreferences);\n  }\n\n  /**\n   * Analyze using Cloudflare AI (Workers AI)\n   * Available on Workers Paid plan\n   */\n  async analyzeWithCloudflareAI(content, userPreferences) {\n    try {\n      const prompt = this.buildAnalysisPrompt(content, userPreferences);\n      \n      const response = await this.env.AI.run('@cf/meta/llama-2-7b-chat-int8', {\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a content analyst. Provide quality and relevance scores (0-1).'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ]\n      });\n\n      // Parse response and extract scores\n      const text = response.response || '';\n      \n      return {\n        qualityScore: this.extractScore(text, 'quality') || 0.7,\n        relevanceScore: this.extractScore(text, 'relevance') || 0.5,\n        detectedTopics: content.tags || [],\n        estimatedValue: content.price || 0.25,\n        summary: text.substring(0, 200)\n      };\n\n    } catch (error) {\n      console.error('Cloudflare AI error:', error);\n      return this.fallbackAnalysis(content, userPreferences);\n    }\n  }\n\n  /**\n   * Analyze using OpenAI API\n   */\n  async analyzeWithOpenAI(content, userPreferences) {\n    try {\n      const prompt = this.buildAnalysisPrompt(content, userPreferences);\n      \n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.openaiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          model: 'gpt-4-turbo-preview',\n          messages: [\n            {\n              role: 'system',\n              content: 'You are a content analyst. Respond only in JSON format.'\n            },\n            {\n              role: 'user',\n              content: prompt\n            }\n          ],\n          temperature: 0.7,\n          max_tokens: 500,\n          response_format: { type: \"json_object\" }\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`OpenAI API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const analysis = JSON.parse(data.choices[0].message.content);\n\n      return {\n        qualityScore: analysis.qualityScore || 0.7,\n        relevanceScore: analysis.relevanceScore || 0.5,\n        detectedTopics: analysis.detectedTopics || content.tags || [],\n        estimatedValue: analysis.estimatedValue || content.price || 0.25,\n        summary: analysis.summary || 'No summary available'\n      };\n\n    } catch (error) {\n      console.error('OpenAI API error:', error);\n      return this.fallbackAnalysis(content, userPreferences);\n    }\n  }\n\n  /**\n   * Fallback analysis using keyword matching\n   */\n  fallbackAnalysis(content, userPreferences) {\n    const userKeywords = userPreferences.interests?.map(i => i.toLowerCase()) || [];\n    const contentKeywords = [\n      ...content.tags?.map(t => t.toLowerCase()) || [],\n      content.title.toLowerCase()\n    ];\n\n    const matchCount = contentKeywords.filter(k =>\n      userKeywords.some(uk => k.includes(uk) || uk.includes(k))\n    ).length;\n\n    const relevanceScore = Math.min(matchCount / Math.max(userKeywords.length, 1), 1);\n\n    return {\n      qualityScore: 0.7,\n      relevanceScore,\n      detectedTopics: content.tags || [],\n      estimatedValue: content.price || 0.25,\n      summary: content.description || 'No summary available'\n    };\n  }\n\n  /**\n   * Make payment decision based on analysis\n   */\n  async makePaymentDecision(content, analysis, userPreferences) {\n    const minQualityScore = parseFloat(this.env.MIN_QUALITY_SCORE || '0.7');\n    \n    // Check quality threshold\n    if (analysis.qualityScore < minQualityScore) {\n      return {\n        shouldPay: false,\n        amount: 0,\n        reason: 'Content quality below threshold',\n        confidenceScore: 0.9,\n        contentId: content.contentId,\n        creatorAddress: content.creatorAddress\n      };\n    }\n\n    // Calculate adjusted amount\n    const baseAmount = content.price || (analysis.estimatedValue * 0.25);\n    const adjustedAmount = baseAmount * analysis.relevanceScore * analysis.qualityScore;\n\n    // Check minimum threshold\n    const minThreshold = parseFloat(this.env.PAYMENT_THRESHOLD || '0.10');\n    if (adjustedAmount < minThreshold) {\n      return {\n        shouldPay: false,\n        amount: 0,\n        reason: 'Payment amount below threshold',\n        confidenceScore: 0.8,\n        contentId: content.contentId,\n        creatorAddress: content.creatorAddress\n      };\n    }\n\n    // Check if creator is favorite\n    const isFavorite = userPreferences.favoriteCreators?.includes(content.creatorAddress);\n\n    return {\n      shouldPay: true,\n      amount: adjustedAmount,\n      reason: isFavorite\n        ? 'Favorite creator with high-quality content'\n        : 'Content meets quality and relevance criteria',\n      confidenceScore: (analysis.qualityScore + analysis.relevanceScore) / 2,\n      contentId: content.contentId,\n      creatorAddress: content.creatorAddress\n    };\n  }\n\n  /**\n   * Recommend content\n   */\n  async recommendContent(userPreferences, availableContent) {\n    if (!availableContent || availableContent.length === 0) {\n      return [];\n    }\n\n    // Score each content item\n    const scored = await Promise.all(\n      availableContent.map(async content => {\n        const analysis = await this.analyzeContent(content, userPreferences);\n        return {\n          ...content,\n          score: (analysis.qualityScore + analysis.relevanceScore) / 2\n        };\n      })\n    );\n\n    // Sort by score\n    scored.sort((a, b) => b.score - a.score);\n\n    // Return top 10\n    return scored.slice(0, 10).map(({ score, ...content }) => content);\n  }\n\n  /**\n   * Build analysis prompt\n   */\n  buildAnalysisPrompt(content, userPreferences) {\n    return `Analyze this content and provide scores:\n\nContent:\n- Title: ${content.title}\n- Type: ${content.type}\n- Description: ${content.description}\n- Tags: ${content.tags?.join(', ')}\n- Price: $${content.price}\n\nUser Interests: ${userPreferences.interests?.join(', ')}\n\nProvide JSON with:\n{\n  \"qualityScore\": 0-1,\n  \"relevanceScore\": 0-1,\n  \"detectedTopics\": [\"topic1\", \"topic2\"],\n  \"estimatedValue\": suggested USD price,\n  \"summary\": brief summary\n}`;\n  }\n\n  /**\n   * Extract score from text response\n   */\n  extractScore(text, type) {\n    const regex = new RegExp(`${type}[:\\\\s]+([0-9.]+)`, 'i');\n    const match = text.match(regex);\n    return match ? parseFloat(match[1]) : null;\n  }\n}\n", "/**\n * Subscription Service for Cloudflare Workers\n * Manages recurring payments using KV storage\n */\n\nimport { PaymentService } from './payment_service.js';\n\nexport class SubscriptionService {\n  constructor(env) {\n    this.env = env;\n    this.paymentService = new PaymentService(env);\n  }\n\n  /**\n   * Create new subscription\n   */\n  async createSubscription(userId, creatorAddress, amount, env) {\n    const subscriptionId = `${userId}-${creatorAddress}-${Date.now()}`;\n    \n    const nextPaymentDate = new Date();\n    nextPaymentDate.setDate(nextPaymentDate.getDate() + 30);\n\n    const subscription = {\n      subscriptionId,\n      userId,\n      creatorAddress,\n      amount,\n      nextPaymentDate: nextPaymentDate.toISOString(),\n      active: true,\n      createdAt: new Date().toISOString(),\n      lastPaymentDate: new Date().toISOString()\n    };\n\n    // Store in KV\n    await env.SUBSCRIPTIONS.put(subscriptionId, JSON.stringify(subscription));\n\n    // Process first payment immediately\n    try {\n      await this.processPayment(subscriptionId, env);\n    } catch (error) {\n      console.error('First payment failed:', error);\n      // Keep subscription active even if first payment fails\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Process subscription payment\n   */\n  async processPayment(subscriptionId, env) {\n    const subData = await env.SUBSCRIPTIONS.get(subscriptionId);\n    \n    if (!subData) {\n      throw new Error('Subscription not found');\n    }\n\n    const subscription = JSON.parse(subData);\n\n    if (!subscription.active) {\n      throw new Error('Subscription is not active');\n    }\n\n    // Create payment decision\n    const decision = {\n      shouldPay: true,\n      amount: subscription.amount,\n      reason: 'Subscription payment',\n      confidenceScore: 1.0,\n      contentId: `sub-${subscriptionId}`,\n      creatorAddress: subscription.creatorAddress\n    };\n\n    // Process payment\n    const transaction = await this.paymentService.processMicropayment(\n      subscription.userId,\n      decision,\n      env\n    );\n\n    // Update subscription\n    subscription.lastPaymentDate = new Date().toISOString();\n    const nextPaymentDate = new Date();\n    nextPaymentDate.setDate(nextPaymentDate.getDate() + 30);\n    subscription.nextPaymentDate = nextPaymentDate.toISOString();\n\n    // Save updated subscription\n    await env.SUBSCRIPTIONS.put(subscriptionId, JSON.stringify(subscription));\n\n    return transaction;\n  }\n\n  /**\n   * Check for due subscriptions (called by cron)\n   */\n  async checkDueSubscriptions() {\n    const now = new Date();\n    \n    // List all subscriptions\n    const listResult = await this.env.SUBSCRIPTIONS.list();\n    \n    for (const key of listResult.keys) {\n      try {\n        const subData = await this.env.SUBSCRIPTIONS.get(key.name);\n        const subscription = JSON.parse(subData);\n\n        // Check if payment is due\n        if (subscription.active && new Date(subscription.nextPaymentDate) <= now) {\n          console.log(`Processing due subscription: ${subscription.subscriptionId}`);\n          await this.processPayment(subscription.subscriptionId, this.env);\n        }\n      } catch (error) {\n        console.error(`Failed to process subscription ${key.name}:`, error);\n        // Continue with other subscriptions\n      }\n    }\n  }\n\n  /**\n   * Cancel subscription\n   */\n  async cancelSubscription(subscriptionId, env) {\n    const subData = await env.SUBSCRIPTIONS.get(subscriptionId);\n    \n    if (!subData) {\n      return false;\n    }\n\n    const subscription = JSON.parse(subData);\n    subscription.active = false;\n    subscription.cancelledAt = new Date().toISOString();\n\n    await env.SUBSCRIPTIONS.put(subscriptionId, JSON.stringify(subscription));\n    return true;\n  }\n\n  /**\n   * Reactivate subscription\n   */\n  async reactivateSubscription(subscriptionId, env) {\n    const subData = await env.SUBSCRIPTIONS.get(subscriptionId);\n    \n    if (!subData) {\n      return false;\n    }\n\n    const subscription = JSON.parse(subData);\n    subscription.active = true;\n    delete subscription.cancelledAt;\n\n    // Set next payment date\n    const nextPaymentDate = new Date();\n    nextPaymentDate.setDate(nextPaymentDate.getDate() + 30);\n    subscription.nextPaymentDate = nextPaymentDate.toISOString();\n\n    await env.SUBSCRIPTIONS.put(subscriptionId, JSON.stringify(subscription));\n    return true;\n  }\n}\n", "/**\n * AI Content Payment Agent - Cloudflare Workers Edition\n * \n * Serverless AI agent running on Cloudflare's edge network\n * Processes content analysis and USDC payments in real-time\n */\n\nimport { PaymentService } from './payment_service.js';\nimport { OpenAIService } from './openai_service.js';\nimport { SubscriptionService } from './subscription_service.js';\n\n/**\n * Main Worker Request Handler\n * @param {Request} request \n * @param {Object} env - Environment bindings (KV, secrets, etc)\n * @param {Object} ctx - Execution context\n */\nexport default {\n  async fetch(request, env, ctx) {\n    // CORS headers for all responses\n    const corsHeaders = {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    };\n\n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      const url = new URL(request.url);\n      const path = url.pathname;\n\n      // Initialize services\n      const paymentService = new PaymentService(env);\n      const openaiService = new OpenAIService(env);\n      const subscriptionService = new SubscriptionService(env);\n\n      // Route handling\n      let response;\n\n      // Health check\n      if (path === '/health') {\n        response = await handleHealth(env);\n      }\n      // User preferences\n      else if (path.match(/^\\/api\\/users\\/[^/]+\\/preferences$/)) {\n        const userId = path.split('/')[3];\n        if (request.method === 'POST') {\n          response = await handleSetPreferences(request, userId, env);\n        } else if (request.method === 'GET') {\n          response = await handleGetPreferences(userId, env);\n        }\n      }\n      // Process content (AI analysis + payment)\n      else if (path.match(/^\\/api\\/users\\/[^/]+\\/content\\/process$/)) {\n        const userId = path.split('/')[3];\n        response = await handleProcessContent(\n          request, \n          userId, \n          env, \n          openaiService, \n          paymentService\n        );\n      }\n      // Get recommendations\n      else if (path.match(/^\\/api\\/users\\/[^/]+\\/recommendations$/)) {\n        const userId = path.split('/')[3];\n        response = await handleRecommendations(request, userId, env, openaiService);\n      }\n      // Send tip\n      else if (path.match(/^\\/api\\/users\\/[^/]+\\/tip$/)) {\n        const userId = path.split('/')[3];\n        response = await handleSendTip(request, userId, env, paymentService);\n      }\n      // Subscriptions\n      else if (path.match(/^\\/api\\/users\\/[^/]+\\/subscriptions$/)) {\n        const userId = path.split('/')[3];\n        if (request.method === 'POST') {\n          response = await handleCreateSubscription(\n            request, \n            userId, \n            env, \n            subscriptionService\n          );\n        } else if (request.method === 'GET') {\n          response = await handleGetSubscriptions(userId, env);\n        }\n      }\n      // Get statistics\n      else if (path === '/api/statistics') {\n        response = await handleStatistics(env);\n      }\n      // Handle user registration\n      else if ((path === '/auth/signup' || path === '/api/auth/signup') && request.method === 'POST') {\n        response = await handleSignUp(request, env);\n      }\n      // Handle user sign-in\n      else if ((path === '/auth/signin' || path === '/api/auth/signin') && request.method === 'POST') {\n        response = await handleSignIn(request, env);\n      }\n      else {\n        response = jsonResponse({ error: 'Not found' }, 404);\n      }\n\n      // Add CORS headers to response\n      Object.keys(corsHeaders).forEach(key => {\n        response.headers.set(key, corsHeaders[key]);\n      });\n\n      return response;\n\n    } catch (error) {\n      console.error('Worker error:', error);\n      return jsonResponse(\n        { error: 'Internal server error', message: error.message },\n        500,\n        corsHeaders\n      );\n    }\n  },\n\n  /**\n   * Cron trigger for subscription checks\n   * Runs every hour to process due subscriptions\n   */\n  async scheduled(event, env, ctx) {\n    console.log('Running scheduled subscription check...');\n    \n    try {\n      const subscriptionService = new SubscriptionService(env);\n      await subscriptionService.checkDueSubscriptions();\n      console.log('Subscription check completed successfully');\n    } catch (error) {\n      console.error('Subscription check failed:', error);\n    }\n  }\n};\n\n/**\n * Health check endpoint\n */\nasync function handleHealth(env) {\n  return jsonResponse({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    version: '1.0.0',\n    environment: env.ENVIRONMENT || 'development',\n    edge: true // Cloudflare Workers runs on edge\n  });\n}\n\n/**\n * Set user preferences\n */\nasync function handleSetPreferences(request, userId, env) {\n  const preferences = await request.json();\n  \n  // Store in KV\n  await env.USER_PREFS.put(\n    userId,\n    JSON.stringify({\n      ...preferences,\n      userId,\n      updatedAt: new Date().toISOString()\n    })\n  );\n\n  return jsonResponse({\n    success: true,\n    message: 'Preferences saved',\n    preferences\n  });\n}\n\n/**\n * Get user preferences\n */\nasync function handleGetPreferences(userId, env) {\n  const prefsData = await env.USER_PREFS.get(userId);\n  \n  if (!prefsData) {\n    return jsonResponse({ error: 'Preferences not found' }, 404);\n  }\n\n  return jsonResponse({\n    success: true,\n    preferences: JSON.parse(prefsData)\n  });\n}\n\n/**\n * Process content with AI analysis and payment\n */\nasync function handleProcessContent(request, userId, env, openaiService, paymentService) {\n  const content = await request.json();\n  \n  // Get user preferences\n  const prefsData = await env.USER_PREFS.get(userId);\n  if (!prefsData) {\n    return jsonResponse({ error: 'User preferences not found' }, 404);\n  }\n  const preferences = JSON.parse(prefsData);\n\n  // Check daily budget\n  const today = new Date().toDateString();\n  const spendingKey = `${userId}-${today}`;\n  const dailySpending = parseFloat(await env.PAYMENT_HISTORY.get(spendingKey) || '0');\n\n  if (dailySpending >= preferences.maxDailyBudget) {\n    return jsonResponse({\n      success: true,\n      decision: {\n        shouldPay: false,\n        amount: 0,\n        reason: 'Daily budget exceeded',\n        confidenceScore: 1.0,\n        contentId: content.contentId,\n        creatorAddress: content.creatorAddress\n      }\n    });\n  }\n\n  // AI Analysis\n  const analysis = await openaiService.analyzeContent(content, preferences);\n  const decision = await openaiService.makePaymentDecision(content, analysis, preferences);\n\n  // If should pay, process payment\n  if (decision.shouldPay) {\n    const remainingBudget = preferences.maxDailyBudget - dailySpending;\n    \n    if (decision.amount > remainingBudget) {\n      decision.shouldPay = false;\n      decision.reason = 'Would exceed daily budget';\n    } else {\n      try {\n        const transaction = await paymentService.processMicropayment(\n          userId,\n          decision,\n          env\n        );\n\n        // Update daily spending\n        await env.PAYMENT_HISTORY.put(\n          spendingKey,\n          String(dailySpending + decision.amount),\n          { expirationTtl: 86400 } // Expire after 24 hours\n        );\n\n        // Save transaction record\n        const txKey = `tx-${transaction.txHash}`;\n        await env.PAYMENT_HISTORY.put(\n          txKey,\n          JSON.stringify({\n            userId,\n            contentId: content.contentId,\n            transaction,\n            decision,\n            timestamp: new Date().toISOString()\n          })\n        );\n\n        return jsonResponse({\n          success: true,\n          decision,\n          transaction\n        });\n      } catch (error) {\n        console.error('Payment failed:', error);\n        decision.shouldPay = false;\n        decision.reason = `Payment failed: ${error.message}`;\n      }\n    }\n  }\n\n  return jsonResponse({\n    success: true,\n    decision\n  });\n}\n\n/**\n * Get AI-powered content recommendations\n */\nasync function handleRecommendations(request, userId, env, openaiService) {\n  const { content } = await request.json();\n  \n  const prefsData = await env.USER_PREFS.get(userId);\n  if (!prefsData) {\n    return jsonResponse({ error: 'User preferences not found' }, 404);\n  }\n  const preferences = JSON.parse(prefsData);\n\n  const recommendations = await openaiService.recommendContent(preferences, content);\n\n  return jsonResponse({\n    success: true,\n    recommendations\n  });\n}\n\n/**\n * Send tip to creator\n */\nasync function handleSendTip(request, userId, env, paymentService) {\n  const { creatorAddress, amount } = await request.json();\n\n  if (!creatorAddress || !amount) {\n    return jsonResponse({ error: 'Missing required fields' }, 400);\n  }\n\n  const prefsData = await env.USER_PREFS.get(userId);\n  if (!prefsData) {\n    return jsonResponse({ error: 'User preferences not found' }, 404);\n  }\n  const preferences = JSON.parse(prefsData);\n\n  // Check daily budget\n  const today = new Date().toDateString();\n  const spendingKey = `${userId}-${today}`;\n  const dailySpending = parseFloat(await env.PAYMENT_HISTORY.get(spendingKey) || '0');\n  const remainingBudget = preferences.maxDailyBudget - dailySpending;\n\n  if (amount > remainingBudget) {\n    return jsonResponse({\n      error: `Tip exceeds remaining daily budget (${remainingBudget} USD)`\n    }, 400);\n  }\n\n  const decision = {\n    shouldPay: true,\n    amount,\n    reason: 'Manual tip',\n    confidenceScore: 1.0,\n    contentId: 'tip-' + Date.now(),\n    creatorAddress\n  };\n\n  const transaction = await paymentService.processMicropayment(userId, decision, env);\n\n  // Update spending\n  await env.PAYMENT_HISTORY.put(\n    spendingKey,\n    String(dailySpending + amount),\n    { expirationTtl: 86400 }\n  );\n\n  return jsonResponse({\n    success: true,\n    message: 'Tip sent successfully',\n    transaction\n  });\n}\n\n/**\n * Create subscription\n */\nasync function handleCreateSubscription(request, userId, env, subscriptionService) {\n  const { creatorAddress, amount } = await request.json();\n\n  if (!creatorAddress || !amount) {\n    return jsonResponse({ error: 'Missing required fields' }, 400);\n  }\n\n  const subscription = await subscriptionService.createSubscription(\n    userId,\n    creatorAddress,\n    amount,\n    env\n  );\n\n  return jsonResponse({\n    success: true,\n    message: 'Subscription created',\n    subscription\n  });\n}\n\n/**\n * Get user subscriptions\n */\nasync function handleGetSubscriptions(userId, env) {\n  // List all subscription keys for user\n  const listResult = await env.SUBSCRIPTIONS.list({ prefix: `${userId}-` });\n  \n  const subscriptions = await Promise.all(\n    listResult.keys.map(async key => {\n      const data = await env.SUBSCRIPTIONS.get(key.name);\n      return JSON.parse(data);\n    })\n  );\n\n  return jsonResponse({\n    success: true,\n    subscriptions\n  });\n}\n\n/**\n * Get system statistics\n */\nasync function handleStatistics(env) {\n  // This would aggregate from KV data in production\n  // For now, return basic stats\n  \n  return jsonResponse({\n    success: true,\n    statistics: {\n      message: 'Statistics aggregation from KV in progress',\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\n/**\n * Handle user sign up\n */\nasync function handleSignUp(request, env) {\n  const { email, password, name } = await request.json();\n\n  if (!email || !password || !name) {\n    return jsonResponse({ error: 'Missing required fields' }, 400);\n  }\n\n  // Check if user already exists\n  const existingUser = await env.USERS.get(`user:${email}`);\n  if (existingUser) {\n    return jsonResponse({ error: 'User with this email already exists' }, 409);\n  }\n\n  // In a real app, you'd hash the password securely\n  const user = { email, password, name, userId: `user-${Date.now()}` };\n  await env.USERS.put(`user:${email}`, JSON.stringify(user));\n\n  // In a real app, you'd generate a proper JWT\n  const token = `fake-token-${Date.now()}`;\n  const { password: _, ...userWithoutPassword } = user;\n\n  return jsonResponse({\n    success: true,\n    message: 'User created successfully',\n    user: userWithoutPassword,\n    token\n  }, 201);\n}\n\n/**\n * Handle user sign in\n */\nasync function handleSignIn(request, env) {\n  const { email, password } = await request.json();\n\n  if (!email || !password) {\n    return jsonResponse({ error: 'Missing required fields' }, 400);\n  }\n\n  let userData = await env.USERS.get(`user:${email}`);\n\n  // If user not found, check for demo user\n  if (!userData && email === 'demo@arcpay.com' && password === 'Demo@123') {\n      const demoUser = { email, password, name: 'Demo User', userId: 'user-demo' };\n      await env.USERS.put(`user:${email}`, JSON.stringify(demoUser));\n      userData = JSON.stringify(demoUser);\n  }\n\n  if (userData) {\n    const user = JSON.parse(userData);\n    if (user.password === password) {\n      // In a real app, you'd generate a proper JWT\n      const token = `fake-token-${Date.now()}`;\n      const { password: _, ...userWithoutPassword } = user;\n      return jsonResponse({\n        success: true,\n        message: 'Sign-in successful',\n        user: userWithoutPassword,\n        token\n      });\n    }\n  }\n\n  return jsonResponse({ error: 'Invalid credentials' }, 401);\n}\n\n/**\n * Helper function to create JSON responses\n */\nfunction jsonResponse(data, status = 200, additionalHeaders = {}) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...additionalHeaders\n    }\n  });\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/subhransu/Desktop/arc-pay-new/backend/index.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/subhransu/Desktop/arc-pay-new/backend/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/subhransu/Desktop/arc-pay-new/backend/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/subhransu/Desktop/arc-pay-new/backend/index.js\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/subhransu/Desktop/arc-pay-new/backend/.wrangler/tmp/bundle-o2i6jh/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/subhransu/Desktop/arc-pay-new/backend/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/subhransu/Desktop/arc-pay-new/backend/.wrangler/tmp/bundle-o2i6jh/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/subhransu/Desktop/arc-pay-new/backend/.wrangler/tmp/bundle-o2i6jh/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
